<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../shared-styles.html">

<dom-module id="katamino-figure">
    <template>
        <style include="shared-styles">
            :host {
                display: block;
                line-height: 0;
            }

            svg rect {

                cursor: pointer;
            }

            :host([hovered]){
                z-index:2;
            }


            :host([hovered]) rect{
                fill: black;
                z-index:2;
            }
        </style>

        <svg id="svg" width$="[[gridWidth]]" height$="[[gridHeight]]" xmlns="http://www.w3.org/2000/svg">


            <template is="dom-repeat" items="[[spec.shape]]" index-as="idx1">
                <template id="figure" is="dom-repeat" items="[[item]]" index-as="idx2">
                    <template is="dom-if" if="{{item}}">
                        <rect x$="[[_getPos(idx2)]]" y$="[[_getPos(idx1)]]" width$="[[gridSpec.wide]]" height$="[[gridSpec.wide]]" fill$="[[spec.color]]"/>
                    </template>
                </template>
            </template>

        </svg>

    </template>

    <script>

        // START SVG HACK
        var doc = document.currentScript.ownerDocument;
        var root = doc.querySelector('dom-module > template').content;
        var templates = root.querySelectorAll('svg template');
        var el, template, attribs, attrib, count, child, content;
        for (var i=0; i<templates.length; i++) {
            el = templates[i];
            template = el.ownerDocument.createElement('template');
            el.parentNode.insertBefore(template, el);
            attribs = el.attributes;
            count = attribs.length;
            while (count-- > 0) {
                attrib = attribs[count];
                template.setAttribute(attrib.name, attrib.value);
                el.removeAttribute(attrib.name);
            }
            el.parentNode.removeChild(el);
            content = template.content;
            while ((child = el.firstChild)) {
                content.appendChild(child);
            }
        }
        // END SVG HACK


        class KataminoFigure extends Polymer.Element {
            static get is() {
                return 'katamino-figure';
            }

            static get properties() {
                return {
                    spec: Object,
                    gridSpec: Object,
                    gridStockSpec: Object,
                    dndSpec: Object,
                    rotation: {
                        type: Number,
                        value:0
                    },
                    hovered: {
                        type: Boolean,
                        value:false
                    }
                }
            }

            static get observers() {
                return [
                    // Observer method name, followed by a list of dependencies, in parenthesis
                    '_specChanged(spec.*, gridSpec.*, gridStockSpec.*, dndSpec.*)'
                ]
            }

            ready() {
                super.ready();
                this._setDragAndDrop();
            }


            _specChanged() {
                this.set('gridWidth', this.gridSpec.wide*this.spec.shape[0].length );
                this.set('gridHeight',  this.gridSpec.wide*this.spec.shape.length );

            }

            _getPos(i){
                return this.gridSpec.wide*i;
            }


            _getTargets(){

                var self = this;

                var targets = [];

                // Stock area
                for( var i = 0; i < (self.gridStockSpec.nrOfRows-(self.spec.shape.length-1)); i++){
                    for( var y = 0; y < self.gridStockSpec.nrPerRow-(self.spec.shape[0].length-1); y++){
                        targets.push({x: self.dndSpec.offsetStockLeft+y*self.gridStockSpec.wide, y: self.dndSpec.offsetStockTop+i*self.gridStockSpec.wide});
                    }
                }

                for( var i = 0; i < (self.gridSpec.nrOfRows-(self.spec.shape.length-1)); i++){
                    for( var y = 0; y < self.gridSpec.nrPerRow-(self.spec.shape[0].length-1); y++){
                        targets.push({x: self.dndSpec.offsetLeft+y*self.gridSpec.wide, y: self.dndSpec.offsetTop+i*self.gridSpec.wide});
                    }
                }

                return targets;
            }


            _setDragAndDrop() {
                var self = this;


                Polymer.Async.idlePeriod.run(function() {

                    self.addEventListener("dblclick", function () {
                        self.set("rotation",self.rotation+90);
                        self.style.webkitTransform = self.style.transform = 'rotate('+self.rotation+'deg)';
                    });



                    var p = self.parentNode, container=false;

                    while(p){
                        if( p.host )
                            p=p.host;
                        if( p.tagName === 'APP-HEADER-LAYOUT'){
                            if( p.$.contentContainer ){
                                container= p.$.contentContainer;
                                break;
                            }
                        }
                        p=Polymer.dom(p).parentNode;
                    }


                    var rects = self.$.svg.querySelectorAll('rect');
                    container.isHover=false;

                    for (i = 0; i < rects.length; ++i) {
                        var rect = rects[i];


                        rect.addEventListener("mouseover", function () {
                            if( container.isHover ) return false;
                            container.isHover=true;
                            self.setAttribute("hovered",true);
                            //self.classList.add('hover');
                        });
                        rect.addEventListener("mouseleave", function () {
                            container.isHover=false;
                            self.removeAttribute("hovered");
                        });
                    }


                    var inter = interact(self)
                        .allowFrom('rect')
                        .draggable({
                            // the rect will be the selected element's parent
                            snap: {
                                offset: {x:0, y:0},
                                targets: self._getTargets(),
                                relativePoints: [
                                    { x: 0  , y: 0   }
                                ]
                            },
                            // enable inertial throwing
                            inertia: true,
                            // keep the element within the area of it's parent
                            /*restrict: {
                             restriction: "parent",
                             endOnly: true,
                             elementRect: {top: 0, left: 0, bottom: 1, right: 1}
                             },*/
                            // enable autoScroll
                            autoScroll: true,
                            onstart: function(){
                                console.log('start')
                            },
                            // call this function on every dragmove event
                            onmove: dragMoveListener,
                            // call this function on every dragend event
                            onend: function (event) {
                                /*var textEl = event.target.querySelector('p');

                                 textEl && (textEl.textContent =
                                 'moved a distance of '
                                 + (Math.sqrt(event.dx * event.dx +
                                 event.dy * event.dy) | 0) + 'px');*/
                            }
                        });


                    if( container ) {
                        container.addEventListener("scroll", function () {
                            inter.options.drag.snap.offset.y=-container.scrollTop;
                        });
                    }







                    function dragMoveListener(event) {

                        var target = event.target,
                            // keep the dragged position in the data-x/data-y attributes
                            x = (parseFloat(target.getAttribute('data-x')) || target.style.left ) + event.dx,
                            y = (parseFloat(target.getAttribute('data-y')) || (target.style.top) ) + event.dy;

                        // translate the element
                        /* target.style.webkitTransform =
                         target.style.transform =
                         'translate(' + x + 'px, ' + y + 'px)';*/

                        target.style.top = y + 'px';
                        target.style.left = x + 'px';

                        // update the posiion attributes
                        target.setAttribute('data-x', x);
                        target.setAttribute('data-y', y);
                    }


                });



            }

        }

        window.customElements.define(KataminoFigure.is, KataminoFigure);
    </script>
</dom-module>
