<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../shared-styles.html">

<dom-module id="katamino-figure">
    <template>
        <style include="shared-styles">
            :host {
                display: block;
                line-height: 0;
                position: absolute;
                transition: transform .2s ease-in-out;
            }

            svg rect {

                cursor: pointer;
            }

            :host([hovering]){
                opacity: 0.75;
                z-index: 2;
            }
            :host([dragging]){
                transform: scale(1.1);
                opacity: 0.75;
                z-index: 3;
            }


            :host([dragging]) rect{
            }
        </style>

        <svg id="svg" width$="[[gridWidth]]" height$="[[gridHeight]]" xmlns="http://www.w3.org/2000/svg">

            <template id="figure" is="dom-repeat" items="[[spec.shape]]" index-as="idx1">
                <template is="dom-repeat" items="[[item]]" index-as="idx2">
                    [[idx1]]
                    <template is="dom-if" if="{{item}}">
                        <rect x$="[[_getPos(idx2)]]" y$="[[_getPos(idx1)]]" width$="[[gridSpec.wide]]" height$="[[gridSpec.wide]]" fill$="[[spec.color]]"/>
                    </template>
                </template>
            </template>

        </svg>

    </template>

    <script>

        // START SVG HACK
        var doc = document.currentScript.ownerDocument;
        var root = doc.querySelector('dom-module > template').content;
        var templates = root.querySelectorAll('svg template');
        var el, template, attribs, attrib, count, child, content;
        for (var i=0; i<templates.length; i++) {
            el = templates[i];
            template = el.ownerDocument.createElement('template');
            el.parentNode.insertBefore(template, el);
            attribs = el.attributes;
            count = attribs.length;
            while (count-- > 0) {
                attrib = attribs[count];
                template.setAttribute(attrib.name, attrib.value);
                el.removeAttribute(attrib.name);
            }
            el.parentNode.removeChild(el);
            content = template.content;
            while ((child = el.firstChild)) {
                content.appendChild(child);
            }
        }
        // END SVG HACK


        class KataminoFigure extends Polymer.Element {
            static get is() {
                return 'katamino-figure';
            }

            static get properties() {
                return {
                    spec: Object,
                    gridSpec: Object,
                    gridStockSpec: Object,
                    dndSpec: Object,
                    rotation: {
                        type: Number,
                        value:0
                    },
                    hovered: {
                        type: Boolean,
                        value:false
                    },
                    scaleFalg: {
                        type: Boolean,
                        value:true
                    },
                }
            }

            static get observers() {
                return [
                    // Observer method name, followed by a list of dependencies, in parenthesis
                    '_specChanged(spec.*, gridSpec.*, gridStockSpec.*, dndSpec.*)'
                ]
            }

            ready() {
                super.ready();
                this._setDragAndDrop();
            }


            _specChanged() {
                this.set('gridWidth', this.gridSpec.wide*this.spec.shape[0].length );
                this.set('gridHeight',  this.gridSpec.wide*this.spec.shape.length );

            }

            _getPos(i){
                return this.gridSpec.wide*i;
            }


            _getTargets(){

                var self = this;

                var targets = [];

                // Stock area
                for( var i = 0; i < (self.gridStockSpec.nrOfRows-(self.spec.shape.length-1)); i++){
                    for( var y = 0; y < self.gridStockSpec.nrPerRow-(self.spec.shape[0].length-1); y++){
                        targets.push({x: self.dndSpec.offsetStockLeft+y*self.gridStockSpec.wide, y: self.dndSpec.offsetStockTop+i*self.gridStockSpec.wide});
                    }
                }

                for( var i = 0; i < (self.gridSpec.nrOfRows-(self.spec.shape.length-1)); i++){
                    for( var y = 0; y < self.gridSpec.nrPerRow-(self.spec.shape[0].length-1); y++){
                        targets.push({x: self.dndSpec.offsetLeft+y*self.gridSpec.wide, y: self.dndSpec.offsetTop+i*self.gridSpec.wide});
                    }
                }

                return targets;
            }


            _setRectEvents() {
                var self = this;

                var rects = self.$.svg.querySelectorAll('rect');
                for (i = 0; i < rects.length; ++i) {
                    var rect = rects[i];

                    rect.addEventListener("mouseover", function () {
                        self.setAttribute('hovering',true);
                    });
                    rect.addEventListener("mouseleave", function () {
                        self.removeAttribute('hovering');
                    });
                }
            }

            _flipFigure(){
                var self = this, shape = self.spec.shape, newShape=[];

                self.style.transform = 'scaleX(-1)';
                for(var i = 0; i< shape.length;i++){
                    newShape.push(shape[i].reverse() );
                }
                self._refreshFigure(newShape);
            }

            _rotateFigure(){
                var self = this, shape = self.spec.shape, newShape=[];

                self.style.transform = 'rotate(90deg)';

                for(var y = shape.length-1;y>=0;y--){
                    for(var i = 0; i< shape[0].length;i++){

                        if( newShape.length<=i){
                            newShape.push([]);
                        }
                        newShape[i].push(shape[y][i]);
                    }

                }

                self._refreshFigure(newShape, true);
            }

            _refresh(){
                this.interact.options.drag.snap.targets= this._getTargets();
            }

            _refreshFigure(newShape, rotate){
                var self = this;

                setTimeout(function(){
                    self.spec.shape= newShape;
                    self.set('spec',self.spec);


                    // refresh figure
                    self.$.figure.items = null;
                    self.$.figure.render();
                    self.$.figure.items = newShape;
                    self.$.figure.render();
                    self._setRectEvents();

                    var x= self.style.transition;
                    self.style.transition = 'transform 0s';
                    self.style.transform = '';
                    setTimeout(function(){
                        self.style.transition=x;
                    },1)
                    self._refresh();


                    if( rotate ) {

                        var svg=self.$.svg,
                            w = svg.getAttribute("width"),
                            h = svg.getAttribute("height"),
                            posx = svg.getAttribute("x"),
                            posy = svg.getAttribute("y");

                        svg.setAttribute("width", h);
                        svg.setAttribute("height", w);

                        var dt, dl;

                        if( h > w){
                            dt=Math.ceil((h-w)/2 / self.gridSpec.wide);
                            dl=Math.ceil((w-h)/2 / self.gridSpec.wide);
                        }else{
                            dt=Math.floor((h-w)/2 / self.gridSpec.wide);
                            dl=Math.floor((w-h)/2 / self.gridSpec.wide);
                        }


                        self.style.top = (parseInt(self.style.top)+ dt* self.gridSpec.wide)+"px";
                        self.style.left = (parseInt(self.style.left)+dl * self.gridSpec.wide)+"px";

                    }



                },200);
            }


            _setDragAndDrop() {
                var self = this;


                Polymer.Async.idlePeriod.run(function() {

                    self.addEventListener("dblclick", function () {

                        if( self.rotation === 0) {
                            self._flipFigure();
                        }else{
                            self._rotateFigure();
                        }


                        if( self.rotation < 4) {
                            self.set("rotation", self.rotation + 1);
                        }else{
                            self.set("rotation", 0);
                        }
                    });



                    var p = self.parentNode, container=false;

                    while(p){
                        if( p.host )
                            p=p.host;
                        if( p.tagName === 'APP-HEADER-LAYOUT'){
                            if( p.$.contentContainer ){
                                container= p.$.contentContainer;
                                break;
                            }
                        }
                        p=Polymer.dom(p).parentNode;
                    }

                    self._setRectEvents();

                    self.interact= interact(self)
                        .allowFrom('rect')
                        .draggable({
                            // the rect will be the selected element's parent
                            snap: {
                                offset: {x:0, y:0},
                                targets: self._getTargets(),
                                relativePoints: [
                                    { x: 0  , y: 0   }
                                ]
                            },
                            // enable inertial throwing
                            inertia: true,
                            // enable autoScroll
                            autoScroll: true,
                            onstart: function(){
                                self.setAttribute("dragging",true);
                                console.log('start')
                            },
                            // call this function on every dragmove event
                            onmove: dragMoveListener,
                            // call this function on every dragend event
                            onend: function (event) {
                                self.removeAttribute("dragging");

                                /*var textEl = event.target.querySelector('p');

                                 textEl && (textEl.textContent =
                                 'moved a distance of '
                                 + (Math.sqrt(event.dx * event.dx +
                                 event.dy * event.dy) | 0) + 'px');*/
                            }
                        });


                    if( container ) {
                        container.addEventListener("scroll", function () {
                            self.interact.options.drag.snap.offset.y=-container.scrollTop;
                        });
                    }



                    function dragMoveListener(event) {

                        var target = event.target,
                            // keep the dragged position in the data-x/data-y attributes
                            x = (parseFloat(target.getAttribute('data-x')) || target.style.left ) + event.dx,
                            y = (parseFloat(target.getAttribute('data-y')) || (target.style.top) ) + event.dy;

                        // translate the element
                        /* target.style.webkitTransform =
                         target.style.transform =
                         'translate(' + x + 'px, ' + y + 'px)';*/

                        target.style.top = y + 'px';
                        target.style.left = x + 'px';

                        // update the posiion attributes
                        target.setAttribute('data-x', x);
                        target.setAttribute('data-y', y);
                    }


                });



            }

        }

        window.customElements.define(KataminoFigure.is, KataminoFigure);
    </script>
</dom-module>
